
/*░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
 ░                                                                                                ░
 ░ Jordan T. Gray's                                                                               ░
 ░                                                                                                ░
 ░          HTML Designer                                                                         ░
 ░                                                                                                ░
 ░ FOSS 2022.                                                                                     ░
 ░ License decision pending.                                                                      ░
 ░                                                                                                ░
 ░ https://www.github.com/jdngray77/HTMLDesigner/                                                 ░
 ░ https://www.jordantgray.uk                                                                     ░
 ░                                                                                                ░
 ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░*/

package com.jdngray77.htmldesigner.frontend

import ExitCodes
import com.jdngray77.htmldesigner.MVC
import com.jdngray77.htmldesigner.backend.*
import com.jdngray77.htmldesigner.backend.data.AutoLoad
import com.jdngray77.htmldesigner.backend.data.Project
import com.jdngray77.htmldesigner.backend.data.config.Config
import com.jdngray77.htmldesigner.backend.data.config.Configs
import com.jdngray77.htmldesigner.frontend.Editor.Companion.EDITOR
import com.jdngray77.htmldesigner.utility.*
import javafx.application.Application
import javafx.application.Platform
import javafx.scene.Scene
import javafx.scene.control.Alert
import javafx.scene.control.ButtonType
import javafx.scene.control.MenuBar
import javafx.stage.DirectoryChooser
import javafx.stage.FileChooser
import javafx.stage.Stage
import java.lang.System.gc
import java.util.*
import kotlin.system.exitProcess
import kotlin.test.assertNotNull


/**
 * Main entry point to the front end.
 *
 * Launches the FXML, configures and stores
 * references to the [EDITOR] and the [mvc].
 */
class Editor : Application() {

    companion object {

        private val ButtonTypeLoad = ButtonType("Load existing Project")

        private val ButtonTypeCreate = ButtonType("Create a new Project")

        /**
         * Meta data about the editor.
         *
         * i.e the IDE verions numbers and stuff.
         */
        val properties: Properties = let {
            val input = this::class.java.getResourceAsStream("meta.properties")
                ?: throw Error("Could not find meta.properties - this is generated by our gradle script at build - Try running gradle build.")

            val prop = Properties()
            prop.load(input)
            return@let prop
        }

        fun getVersionString() = "${properties.getProperty("branchName")}@${properties.getProperty("gitHash")}"

        /**
         * A static reference to the application instance
         */
        @Deprecated("Don't directly access", ReplaceWith("mvc(), project(), maingui"))
        lateinit var EDITOR : Editor

        /**
         * A flag that is raised when the editor is booted
         * by junit in order to test the editor.
         */
        var TESTING = false

        /**
         * Static reference to the model view controller.
         *
         * > ***NOTE WELL : CANNOT BE ACCESSED BEFORE THE EDITOR HAS LOADED.***
         *
         * If accessing from somewhere where the mvc *may* not yet be loaded,
         * consider using [mvcIfAvail]
         */
        fun mvc() = EDITOR.mvc!!

        /**
         * Returns the [mvc], if it is available.
         *
         * Slower, but adds null safety where it's required.
         *
         * For use in places where the access is optional,
         * and calls may be made early - but it doesn't matter
         * if the mvc does not exist yet.
         */
        fun mvcIfAvail() = if (mvcIsAvail()) mvc() else null

        /**
         * Returns true if [mvc] can return the MVC.
         */
        fun mvcIsAvail() : Boolean {
            try {
                return this::EDITOR.isInitialized && EDITOR.mvc != null
            } catch (e : EarlyEditorAccessException) {
                return false
            }
        }

        /**
         * Static reference to the model view controller.
         *
         * > ***NOTE WELL : CANNOT BE ACCESSED IF NOT [mvcIsAvail].***
         */
        fun project() = EDITOR.mvc!!.Project

        /**
         * Static reference to the model view controller.
         *
         * > ***NOTE WELL : CANNOT BE ACCESSED IF NOT [mvcIsAvail].***
         */
        fun maingui() = EDITOR.mvc!!.MainView
    }

    /**
     * The model view controller for the IDE.
     *
     * Acts as a mid-point between the front-end (particularly the current document editor) and back-end.
     */
    var mvc : MVC? = null
        set(value) {
            field = value
        }

    get() = field?: run {throw EarlyEditorAccessException()}

    private class EarlyEditorAccessException() : java.lang.NullPointerException("The Editor or MVC was accessed before it was initialised. Early accesses to a subscriber of EDITOR_LOADED")

    /**
     * A tuple of the JavaFX Scene which hosts the [MainView],
     * and it's [MainViewController].
     *
     * Typically, the controller is accessed using [maingui]
     * via the [mvc]
     */
    lateinit var scene: Pair<Scene, MainViewController>
        private set

    /**
     * The stage that is used to show scenes.
     */
    lateinit var stage: Stage


    /**
     * Loads and initalises the GUI.
     *
     * No access to the editor or the MVC may
     * ocour until this method has returned.
     */
    override fun start(stage: Stage) {

        // Store references
        this.stage = stage
        EDITOR = this

        // Notify early systems to boot.
        // This starts systems that the GUI requires in order
        // to be loaded.
        everyInstanceOf(IDEEarlyBootListener::class).forEach {
            try {
                (it as IDEEarlyBootListener).onIDEBootEarly()
            } catch (e: Exception) {
                e.printStackTrace()
            }
        }

        // Load the main view from FXML.
        // This is the bulk of the load time.
        // It's controller will take over from here.
        scene = loadFXMLScene("MainView.fxml") as Pair<Scene, MainViewController>

        // Fullscreen the window, and show it.
        if (!System.getProperty("os.name").contains("Mac"))
            stage.isFullScreen = true
        else
            if (Config[Configs.USE_MAC_MENU_BOOL] as Boolean)
                (scene.first.lookup("#MenuBar") as MenuBar)
                    .useSystemMenuBarProperty().set(true)


        // Put the main view we just loaded into the window, and show the window.
        stage.scene = scene.first
        stage.show()

        // Run later - return from [start] to allow javafx to create the window, then
        // Run these dialogs and stuff later once the window exists.
        Platform.runLater {
            // Determine a project to load, and create the mvc.
            mvc = MVC(determineProject(), scene.second)

            // For safety, some null checks on the mvc.
            assertNotNull(mvc)
            if (!mvcIsAvail()) {
                showErrorAlert("Encountered a fatal problem after selecting project.\n\n" +
                        "For nerds :\nNo MVC was created after project load?\n\n")

                exitProcess(ExitCodes.ERROR_NO_MVC.ordinal)
            }

            // Notify meta listeners that the GUI and MVC have loaded.
            // Starts up the remaining systems that depend on the GUI or a project.
            EventType.IDE_FINISHED_LOADING.notify()
        }
    }

    /**
     * Interruptable shutdown routine.
     *
     * Performs a clean shutdown of the application.
     *
     * Called by [exit], and by JavaFX.
     *
     * @throws InterruptedException if the shutdown is interrupted, typically by the user.
     */
    @Deprecated("Use 'exit' to request closure.")
    override fun stop() {

        // ==================
        // Perform interruptable operations.
        // Ensure we're clear to shutdown.
        // ==================

        mvcIfAvail()?.apply {
            getOpenEditors().forEach {
                if (!it.requestClose()) {
                    showNotification("Shutdown or restart aborted", "An editor refused to close.")
                    throw InterruptedException("Shutdown or restart aborted. An editor refused to close.")
                }
            }
        }


        // ==================
        // Clear to close. Commit to actually closing IDE.
        // ==================

        EventType.IDE_SHUTDOWN.notify()

        // The event system can't subscribe to itself without causing
        // concurrent modification issues, so we just clear it here.
        EventNotifier.onIDEShutdown()
    }

    /**
     * Requests the application to close.
     *
     * @see stop
     */
    fun exit() {
        stop()
        Platform.exit()
    }

    /**
     * Closes the current project & restarts fresh.
     */
    fun closeProject() {
        AutoLoad.clearLastProjectLoaded()
        restart()
    }

    /**
     * Performs the shutdown routine, then the startup routine.
     *
     * Just be aware that this is a soft restart, so only non-static things are reloaded.
     *
     * Static classes in the JVM persist. For cases where this matters, see [IDEShutdownListener].
     */
    fun restart() {
        stop()
        gc()

        start(stage)
    }


    /**
     * Sub routine of the startup.
     *
     * Determines what the IDE should load.
     *
     * Always returns a project. It's just a matter of figuring out what to load.
     *
     * If [Configs.AUTO_LOAD_PROJECT_BOOL] permits, and [Configs.LAST_PROJECT_PATH_STRING] is set, this will
     * auto load the project path stored.
     *
     * If not, the user will be prompted.
     *
     * Upon load failure, [Configs.LAST_PROJECT_PATH_STRING] will be cleared, for safety.
     * Prevents looping of auto-loads, if the project cannot be loaded.
     *
     * @see usrChooseProject
     */
    private fun determineProject(): Project {
        while (true) {
            try {
                return if (AutoLoad.isAvailable())
                    // If auto-load is available, load the last project.
                    // However, if that fails then just prompt the user anyway.
                    Project.load(AutoLoad.getLastProjectLoaded()) ?: usrChooseProject()
                else
                    // If auto-load is unavailable, prompt the user for a project.
                    usrChooseProject().also {
                        // Store what the user provided for the auto-load.
                        AutoLoad.storeLastProjectLoaded(it.locationOnDisk.path)
                    }


            } catch (e: Exception) {
                // If the project could not be loaded, notify the user and prompt.
                showErrorAlert("Encountered a fatal problem whilst loading project.\n\n" + "${e.message}?")
                e.printStackTrace()

                // For safety. Prevents looping auto-loads, if it can't load the project.
                AutoLoad.clearLastProjectLoaded()
            }
        }
    }

    /**
     * Startup subroutine that prompts the user to choose a project.
     *
     * Will obtain a project from the user,
     * weather it be new or existing, then
     * returns it.
     *
     * Handles cancellation & problems.
     *
     * User will just be prompted [implUsrSelectProject] until a project is obtained.
     *
     * This will not return until the user has chosen a project.
     */
    private fun usrChooseProject() : Project {
        var projToLoad : Project? = null

        while (true) {
            try {
                projToLoad = implUsrSelectProject()
            } catch (e: Exception) {
                showErrorAlert("Project access failed : \n(${e::class.simpleName})\n\n${e.message ?: "No reason was provided"}")
            }

            if (projToLoad == null)
                continue
            else
                return projToLoad
        }
    }

    /**
     * A subroutine of [usrChooseProject]
     * where a flow of dialogs and choosers are used to create
     * or load a project.
     *
     * Can return null if cancelled, or throw exceptions
     * if project access or creation fails.
     */
    private fun implUsrSelectProject(): Project? =
        when (
            Alert(Alert.AlertType.INFORMATION, "Welcome! What would you like to do?", ButtonTypeCreate, ButtonTypeLoad).also { it.showAndWait() }.result
        ) {

            ButtonTypeLoad -> {
                Project.load(DirectoryChooser().let {
                    it.title = "Locate a project root"
                    it.showDialog(stage)?.path ?: run { return@implUsrSelectProject null }
                })
            }

            ButtonTypeCreate -> {
                Project.create(FileChooser().let {
                    it.title = "Create a new project"
                    it.showSaveDialog(stage).path
                })
            }

            else -> null
        }
}